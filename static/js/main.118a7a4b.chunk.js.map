{"version":3,"sources":["services/users/users.ts","components/user-autocomplete/user-autocomplete.tsx","components/textarea-mentions/textarea-mentions.tsx","components/root/root.tsx","serviceWorker.ts","index.tsx","components/user-autocomplete/user-autocomplete.module.css"],"names":["fetchAllUsers","a","Promise","resolve","allUsers","sort","b","name","fetchUsersByNameOrUsername","valueToFind","searchTerm","toLocaleLowerCase","filter","user","toLowerCase","includes","username","UserAutocomplete","React","memo","forwardRef","ref","cursorPosition","show","onChange","useState","initialUsers","setInitialUsers","users","setUsers","position","setPosition","indexFocus","setIndexFocus","ulRef","useRef","selectCurrent","focusNext","newIndex","length","current","childNodes","scrollIntoView","focusPrevious","useEffect","fetch","undefined","top","left","height","useImperativeHandle","className","Styles","UserDropdown","style","console","log","map","index","FocusUser","onClick","key","loading","UserAvatar","src","avatar_url","alt","TextareaMentions","onMention","props","setSearchTerm","setCursorPosition","replacePosition","setReplacePosition","setShow","userAutocompleteRef","event","currentTarget","wordOnCursor","value","selectionStart","selectionEnd","wordRegex","exec","lastIndex","findWordOnCursor","startsWith","cursor","getCaretCoordinates","start","end","slice","onKeyDown","preventDefault","Root","textareaRef","text","setText","textAlt","setTextAlt","placeholder","rows","trimLeft","replace","setTimeout","focus","setSelectionRange","contentEditable","backgroundColor","dangerouslySetInnerHTML","__html","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","module","exports"],"mappings":"uRAOO,SAAeA,IAAtB,+B,4CAAO,sBAAAC,EAAA,+EACEC,QAAQC,QACbC,EAASC,MAAK,SAACJ,EAAGK,GAChB,OAAIL,EAAEM,KAAOD,EAAEC,KACN,EAELN,EAAEM,KAAOD,EAAEC,MACL,EAEH,OATN,4C,sBAeA,SAASC,EACdC,GAEA,IAAMC,EAAaD,EAAYE,oBAC/B,OAAOT,QAAQC,QACbC,EAASQ,QACP,SAAAC,GAAI,OACFA,EAAKN,KAAKO,cAAcC,SAASL,IACjCG,EAAKG,SAASF,cAAcC,SAASL,O,oBCFhCO,EAAmBC,IAAMC,KACpCC,sBACE,WAAiDC,GAAS,IAAvDX,EAAsD,EAAtDA,WAAYY,EAA0C,EAA1CA,eAAgBC,EAA0B,EAA1BA,KAAMC,EAAoB,EAApBA,SAAoB,EACfC,mBAAiB,IADF,mBAChDC,EADgD,KAClCC,EADkC,OAE7BF,mBAAiB,IAFY,mBAEhDG,EAFgD,KAEzCC,EAFyC,OAGvBJ,qBAHuB,mBAGhDK,EAHgD,KAGtCC,EAHsC,OAInBN,mBAAS,GAJU,mBAIhDO,EAJgD,KAIpCC,EAJoC,KAKjDC,EAAQC,iBAAyB,MA0CvC,SAASC,IACC,OAARZ,QAAQ,IAARA,KAAWI,EAAMI,IAGnB,SAASK,IAAa,IAAD,EACfC,EAAWN,EAAa,EACxBM,GAAYV,EAAMW,SACpBD,EAAW,GAEbL,EAAcK,IACd,UAACJ,EAAMM,eAAP,aAAC,EAAeC,WAAWH,IAA4BI,iBAGzD,SAASC,IAAiB,IAAD,EACnBL,EAAWN,EAAa,EACxBM,EAAW,IACbA,EAAWV,EAAMW,OAAS,IAE5B,UAACL,EAAMM,eAAP,aAAC,EAAeC,WAAWH,IAA4BI,iBACvDT,EAAcK,GAQhB,OAnEAM,qBAAU,YACG,uCAAG,4BAAA3C,EAAA,sEACQD,IADR,OACN4B,EADM,OAEZD,EAAgBC,GAFJ,2CAAH,qDAKXiB,KAIC,IAEHD,qBAAU,WACR,IAAKlC,EAGH,OAFAuB,EAAc,QACdJ,EAASH,IAIA,uCAAG,4BAAAzB,EAAA,6DACZgC,EAAc,GADF,SAEQzB,EAA2BE,GAFnC,OAENkB,EAFM,OAGZC,EAASD,GAHG,2CAAH,qDAKXiB,KAIC,CAACnC,EAAYgB,IAEhBkB,qBAAU,WAGR,QAAuBE,IAAnBxB,EAAJ,CAHc,IAMNyB,EAAsBzB,EAAtByB,IAAKC,EAAiB1B,EAAjB0B,KAAMC,EAAW3B,EAAX2B,OACnBlB,EAAY,CAAEgB,IAAKA,EAAME,EAAQD,YAChC,CAAC1B,IAuBJ4B,8BAAoB7B,GAAK,iBAAO,CAC9Be,gBACAC,YACAM,oBAGGpB,GAAyB,IAAjBK,EAAMW,OAMjB,yBAAKY,UAAS,eAAUC,IAAOC,cAAgBC,MAAOxB,GACnDyB,QAAQC,IAAI5B,EAAMW,OAAQP,GAC3B,wBAAImB,UAAU,8BAA8B9B,IAAKa,GAC9CN,EAAM6B,KAAI,SAAC5C,EAAM6C,GAAP,OACT,wBACEP,UAAS,iFACPO,IAAU1B,EAAaoB,IAAOO,UAAY,IAE5CC,QAAS,yBAAMpC,QAAN,IAAMA,OAAN,EAAMA,EAAWX,IAC1BgD,IAAKhD,EAAKG,UAEV,yBAAKmC,UAAU,SACb,yBACEW,QAAQ,OACRX,UAAS,UAAKC,IAAOW,WAAZ,SACTC,IAAKnD,EAAKoD,WACVC,IAAI,WAEN,yBAAKf,UAAU,cACb,uBAAGA,UAAU,QAAQtC,EAAKN,MAC1B,2BAAO4C,UAAU,cAActC,EAAKG,kBAzBzC,SC7DR,IAAMmD,EAAmBhD,eAC9BC,sBAAuC,WAA0BC,GAAS,IAAhC+C,EAA+B,EAA/BA,UAAcC,EAAiB,+BACnC5C,qBADmC,mBAChEf,EADgE,KACpD4D,EADoD,OAE3B7C,qBAF2B,mBAEhEH,EAFgE,KAEhDiD,EAFgD,OAOzB9C,qBAPyB,mBAOhE+C,EAPgE,KAO/CC,EAP+C,OAW/ChD,oBAAS,GAXsC,mBAWhEF,EAXgE,KAW1DmD,EAX0D,KAYjEC,EAAsBxC,iBAC1B,MA4DF,OACE,oCACE,kBAAClB,EAAD,CACEP,WAAYA,EACZc,SAlCgB,SAACX,QACGiC,IAApB0B,IAGK,OAATJ,QAAS,IAATA,KAAYvD,EAAM2D,GAElBF,OAAcxB,GACd4B,GAAQ,KA4BJpD,eAAgBA,EAChBC,KAAMA,EACNF,IAAKsD,IAGP,4CACEtD,IAAKA,GACDgD,EAFN,CAGE7C,SAtEW,SAACoD,GAAmD,IAAD,EAC1DC,EAAkBD,EAAlBC,cACR,UAAAR,EAAM7C,gBAAN,cAAA6C,EAAiBO,GAEjB,IAAME,EAxDZ,YAWE,IAH+B,IAE3BA,EATJC,EAO8B,EAP9BA,MACAC,EAM8B,EAN9BA,eACAC,EAK8B,EAL9BA,aAMMC,EAAY,OAEgC,QAA1CJ,EAAeI,EAAUC,KAAKJ,KACpC,GACED,EAAapB,OAASsB,GACtBE,EAAUE,WAAaH,EAEvB,OAAOH,EAwCcO,CAAiBR,GAEtC,UAAIC,QAAJ,IAAIA,OAAJ,EAAIA,EAAe,GAAGQ,WAAW,KAAM,CAGrC,IAAMC,EAASC,IACbX,EACAA,EAAcI,cACXJ,EAAcI,aAAeH,EAAapB,QAE/Ca,EAAkBgB,GAClBd,EAAmB,CACjBgB,MAAOX,EAAapB,MACpBgC,IAAKZ,EAAapB,MAAQoB,EAAa,GAAGvC,SAE5C+B,EAAcQ,EAAa,GAAGa,MAAM,IACpCjB,GAAQ,QAERA,GAAQ,GACRJ,OAAcxB,IAgDZ8C,UAlCa,SAAChB,GAKU,IAAD,EAJ3B,IAAa,IAATrD,EAIJ,GAAkB,UAAdqD,EAAMf,IACR,UAAAc,EAAoBnC,eAApB,SAA6BJ,gBAC7BwC,EAAMiB,sBACD,GAAkB,QAAdjB,EAAMf,IAAe,CAAC,IAAD,EAC9B,UAAAc,EAAoBnC,eAApB,SAA6BJ,gBAC7BwC,EAAMiB,sBACD,GAAkB,cAAdjB,EAAMf,IAAqB,CAAC,IAAD,EACpC,UAAAc,EAAoBnC,eAApB,SAA6BH,YAC7BuC,EAAMiB,sBACD,GAAkB,YAAdjB,EAAMf,IAAmB,CAAC,IAAD,EAClC,UAAAc,EAAoBnC,eAApB,SAA6BG,gBAC7BiC,EAAMiB,2BC9GP,SAASC,IACd,IAAMC,EAAc5D,iBAA4B,MAD3B,EAEGV,qBAFH,mBAEduE,EAFc,KAERC,EAFQ,OAGSxE,mBAAiB,IAH1B,mBAGdyE,EAHc,KAGLC,EAHK,KAiDrB,OACE,oCACE,yBAAKhD,UAAU,gCACb,yBAAKA,UAAU,aACf,yBAAKA,UAAU,aACb,kBAACgB,EAAD,CACE9C,IAAK0E,EACLK,YAAY,6BACZjD,UAAU,kBACVkD,KAAM,EACNtB,MAAOiB,EACP5B,UAnCN,SAAC,EAAD,GAAyC,IAAtC7D,EAAqC,EAArCA,KAAMS,EAA+B,EAA/BA,SAAcyE,EAAiB,EAAjBA,MAAOC,EAAU,EAAVA,IAEhCO,GACE,SAAAD,GAAI,uBACCA,QADD,IACCA,OADD,EACCA,EAAML,MAAM,EAAGF,GADhB,YAC0BzE,EAD1B,mBACsCgF,QADtC,IACsCA,OADtC,EACsCA,EAAML,MAAMD,GAAKY,eAE7DH,GACE,SAAAH,GAAI,uBACCA,QADD,IACCA,OADD,EACCA,EAAML,MACP,EACAF,GAHA,+CAIsCzE,EAJtC,qCAI2ET,EAJ3E,uBAIuFyF,QAJvF,IAIuFA,OAJvF,EAIuFA,EACrFL,MAAMD,GACPY,gBAuBC9E,SAnBO,SAAC,GAE6B,IAD5BuD,EAC2B,EAD5CF,cAAiBE,MAEjBkB,EAAQlB,GACRoB,EAAWpB,EAAMwB,QAAQ,OAAQ,YAiB3B,4BACEpD,UAAU,wCACVS,QA5DY,WACpB,IAAIrB,EAAS,EAEb0D,GAAQ,SAAAD,GACN,YAAalD,IAATkD,GACFzD,EAAS,QAAQA,OACV,UAETA,EAAS,UAAGyD,EAAH,WAAiBzD,OACpB,GAAN,OAAUyD,EAAV,eAGFQ,YAAW,WAAO,IAAD,IACf,UAAAT,EAAYvD,eAAZ,SAAqBiE,QACrB,UAAAV,EAAYvD,eAAZ,SAAqBkE,kBAAkBnE,EAAS,EAAGA,KAClD,KA2CG,MAOF,yBAAKY,UAAU,aAEf,yBAAKA,UAAU,aACf,yBAAKA,UAAU,YACb,4EACA,yBACEwD,iBAAe,EAKfrD,MAAO,CAAEsD,gBAAiB,OAAQ3D,OAAQ,KAC1C4D,wBAAyB,CACvBC,OAAO,GAAD,OAAKZ,MAGf,yBAAK/C,UAAU,gBC9EL4D,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAACxB,EAAD,OAEFyB,SAASC,eAAe,SD8HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLzE,QAAQyE,MAAMA,EAAMC,a,kBE7I5BC,EAAOC,QAAU,CAAC,aAAe,wCAAwC,WAAa,sCAAsC,UAAY,uC","file":"static/js/main.118a7a4b.chunk.js","sourcesContent":["import allUsers from './UserData.json';\n\ntype User = import('../../models/user').User;\n\n// This is no very realistic. Instead of expecting all the users, it is more common to be given a subset of users\n// (for example: lastest mentioned by the user, or other users that have been referenced him/her).\n// I could emulate a real fetch request with a window.setTimeout\nexport async function fetchAllUsers(): Promise<User[]> {\n  return Promise.resolve(\n    allUsers.sort((a, b) => {\n      if (a.name > b.name) {\n        return 1;\n      }\n      if (a.name < b.name) {\n        return -1;\n      }\n      return 0;\n    })\n  );\n}\n\n// It would more useful to have a more flexible query term (that allows to search by only username, name, sorting, etc.)\nexport function fetchUsersByNameOrUsername(\n  valueToFind: string\n): Promise<User[]> {\n  const searchTerm = valueToFind.toLocaleLowerCase();\n  return Promise.resolve(\n    allUsers.filter(\n      user =>\n        user.name.toLowerCase().includes(searchTerm) ||\n        user.username.toLowerCase().includes(searchTerm)\n    )\n  );\n}\n","import React, {\n  useEffect,\n  useRef,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n} from 'react';\n\nimport {\n  fetchAllUsers,\n  fetchUsersByNameOrUsername,\n} from '../../services/users/users';\n\nimport Styles from './user-autocomplete.module.css';\n\ntype User = import('../../models/user').User;\ntype Ref = {\n  selectCurrent: VoidFunction;\n  focusNext: VoidFunction;\n  focusPrevious: VoidFunction;\n};\ntype Props = {\n  searchTerm?: string; // setting searchTerm to undefined resets to the initial user list\n  cursorPosition?: { top: number; left: number; height: number };\n  show?: boolean;\n  onChange?: (user: User) => void;\n};\n\nexport const UserAutocomplete = React.memo(\n  forwardRef<Ref, Props>(\n    ({ searchTerm, cursorPosition, show, onChange }, ref) => {\n      const [initialUsers, setInitialUsers] = useState<User[]>([]);\n      const [users, setUsers] = useState<User[]>([]);\n      const [position, setPosition] = useState<{ top: number; left: number }>();\n      const [indexFocus, setIndexFocus] = useState(0);\n      const ulRef = useRef<HTMLUListElement>(null);\n\n      useEffect(() => {\n        const fetch = async () => {\n          const users = await fetchAllUsers();\n          setInitialUsers(users);\n        };\n\n        fetch();\n\n        // Cancel request;\n        // return () => { cleanup; };\n      }, []);\n\n      useEffect(() => {\n        if (!searchTerm) {\n          setIndexFocus(0);\n          setUsers(initialUsers);\n          return;\n        }\n\n        const fetch = async () => {\n          setIndexFocus(0);\n          const users = await fetchUsersByNameOrUsername(searchTerm);\n          setUsers(users);\n        };\n        fetch();\n\n        // Cancel request;\n        // return () => { cleanup; };\n      }, [searchTerm, initialUsers]);\n\n      useEffect(() => {\n        // Top, left position maybe very close to the lower or right edges of the 'parent' (textarea or div.contenteditable) bounding box.\n        // TODO: handle those cases.\n        if (cursorPosition === undefined) {\n          return;\n        }\n        const { top, left, height } = cursorPosition;\n        setPosition({ top: top + height, left });\n      }, [cursorPosition]);\n\n      function selectCurrent() {\n        onChange?.(users[indexFocus]);\n      }\n\n      function focusNext() {\n        let newIndex = indexFocus + 1;\n        if (newIndex >= users.length) {\n          newIndex = 0;\n        }\n        setIndexFocus(newIndex);\n        (ulRef.current?.childNodes[newIndex] as HTMLLIElement).scrollIntoView();\n      }\n\n      function focusPrevious() {\n        let newIndex = indexFocus - 1;\n        if (newIndex < 0) {\n          newIndex = users.length - 1;\n        }\n        (ulRef.current?.childNodes[newIndex] as HTMLLIElement).scrollIntoView();\n        setIndexFocus(newIndex);\n      }\n      useImperativeHandle(ref, () => ({\n        selectCurrent,\n        focusNext,\n        focusPrevious,\n      }));\n\n      if (!show || users.length === 0) {\n        return null;\n      }\n\n      // TODO: add spiner while loading the users\n      return (\n        <div className={`card ${Styles.UserDropdown}`} style={position}>\n          {console.log(users.length, indexFocus)}\n          <ul className=\"list-group list-group-flush\" ref={ulRef}>\n            {users.map((user, index) => (\n              <li\n                className={`list-group-item list-group-item-action list-group-item-action py-1 btn ${\n                  index === indexFocus ? Styles.FocusUser : ''\n                }`}\n                onClick={() => onChange?.(user)}\n                key={user.username}\n              >\n                <div className=\"media\">\n                  <img\n                    loading=\"lazy\"\n                    className={`${Styles.UserAvatar} mr-3`}\n                    src={user.avatar_url}\n                    alt=\"avatar\"\n                  />\n                  <div className=\"media-body\">\n                    <p className=\"mb-0\">{user.name}</p>\n                    <small className=\"text-muted\">{user.username}</small>\n                  </div>\n                </div>\n              </li>\n            ))}\n          </ul>\n        </div>\n      );\n    }\n  )\n);\n","import React, { useState, useRef, forwardRef, memo } from 'react';\n\nimport getCaretCoordinates from 'textarea-caret';\n\nimport { UserAutocomplete } from '../user-autocomplete/user-autocomplete';\n\ntype User = import('../../models/user').User;\n\n// TODO: test if this function works RTL languages\nfunction findWordOnCursor({\n  value,\n  selectionStart,\n  selectionEnd,\n}: {\n  value: string;\n  selectionStart: number;\n  selectionEnd: number;\n}): RegExpExecArray | undefined {\n  const wordRegex = /\\S+/g;\n  let wordOnCursor;\n  while ((wordOnCursor = wordRegex.exec(value)) !== null) {\n    if (\n      wordOnCursor.index <= selectionStart &&\n      wordRegex.lastIndex >= selectionEnd\n    ) {\n      return wordOnCursor;\n    }\n  }\n  return undefined;\n}\n\ntype RefFromExotic<T> = T extends React.ForwardRefExoticComponent<\n  React.RefAttributes<infer T2>\n>\n  ? T2\n  : never;\n\ntype Props = {\n  onMention?: (\n    user: User,\n    replacePosition: { start: number; end: number }\n  ) => void;\n} & React.TextareaHTMLAttributes<HTMLTextAreaElement>;\n\nexport const TextareaMentions = memo(\n  forwardRef<HTMLTextAreaElement, Props>(({ onMention, ...props }, ref) => {\n    const [searchTerm, setSearchTerm] = useState<string>();\n    const [cursorPosition, setCursorPosition] = useState<{\n      top: number;\n      left: number;\n      height: number;\n    }>();\n    const [replacePosition, setReplacePosition] = useState<{\n      start: number;\n      end: number;\n    }>();\n    const [show, setShow] = useState(false);\n    const userAutocompleteRef = useRef<RefFromExotic<typeof UserAutocomplete>>(\n      null\n    );\n\n    const onChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {\n      const { currentTarget } = event;\n      props.onChange?.(event);\n\n      const wordOnCursor = findWordOnCursor(currentTarget);\n\n      if (wordOnCursor?.[0].startsWith('@')) {\n        // TODO: take into account top and left initial position of the textarea and\n        // if the cursor is scrolled area (modulus operator [reminder] of cursor top position and height of the textarea)\n        const cursor = getCaretCoordinates(\n          currentTarget,\n          currentTarget.selectionEnd -\n            (currentTarget.selectionEnd - wordOnCursor.index) // calculate X, Y as if the cursor would be on the caret\n        );\n        setCursorPosition(cursor);\n        setReplacePosition({\n          start: wordOnCursor.index,\n          end: wordOnCursor.index + wordOnCursor[0].length,\n        });\n        setSearchTerm(wordOnCursor[0].slice(1));\n        setShow(true);\n      } else {\n        setShow(false);\n        setSearchTerm(undefined);\n      }\n    };\n\n    const onMentionUser = (user: User) => {\n      if (replacePosition === undefined) {\n        return;\n      }\n      onMention?.(user, replacePosition);\n\n      setSearchTerm(undefined);\n      setShow(false);\n    };\n\n    const handleKeys = (event: React.KeyboardEvent) => {\n      if (show === false) {\n        return;\n      }\n\n      if (event.key === 'Enter') {\n        userAutocompleteRef.current?.selectCurrent();\n        event.preventDefault();\n      } else if (event.key === 'Tab') {\n        userAutocompleteRef.current?.selectCurrent();\n        event.preventDefault();\n      } else if (event.key === 'ArrowDown') {\n        userAutocompleteRef.current?.focusNext();\n        event.preventDefault();\n      } else if (event.key === 'ArrowUp') {\n        userAutocompleteRef.current?.focusPrevious();\n        event.preventDefault();\n      }\n    };\n\n    return (\n      <>\n        <UserAutocomplete\n          searchTerm={searchTerm}\n          onChange={onMentionUser}\n          cursorPosition={cursorPosition}\n          show={show}\n          ref={userAutocompleteRef}\n        ></UserAutocomplete>\n\n        <textarea\n          ref={ref}\n          {...props}\n          onChange={onChange}\n          onKeyDown={handleKeys}\n        ></textarea>\n      </>\n    );\n  })\n);\n","import React, { useState, useRef } from 'react';\n\nimport { TextareaMentions } from '../textarea-mentions/textarea-mentions';\n\nexport function Root() {\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n  const [text, setText] = useState<string>();\n  const [textAlt, setTextAlt] = useState<string>('');\n\n  const insertMention = () => {\n    let length = 0;\n\n    setText(text => {\n      if (text === undefined) {\n        length = '@type'.length;\n        return '@type';\n      }\n      length = `${text}\\n@type`.length;\n      return `${text}\\n@type`;\n    });\n\n    setTimeout(() => {\n      textareaRef.current?.focus();\n      textareaRef.current?.setSelectionRange(length - 4, length);\n    }, 0);\n  };\n\n  const onMention: NonNullable<\n    React.ComponentProps<typeof TextareaMentions>['onMention']\n  > = ({ name, username }, { start, end }) => {\n    // TODO: This replacement assumes LTR language\n    setText(\n      text =>\n        `${text?.slice(0, start)}@${username} ${text?.slice(end).trimLeft()}`\n    );\n    setTextAlt(\n      text =>\n        `${text?.slice(\n          0,\n          start\n        )} <a href=\"https://hypothes.is/users/${username}\" style=\"pointer: cursor\">${name}</a> ${text\n          ?.slice(end)\n          .trimLeft()}`\n    );\n  };\n\n  const onChange = ({\n    currentTarget: { value },\n  }: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setText(value);\n    setTextAlt(value.replace(/\\n/gm, '<br>'));\n  };\n\n  return (\n    <>\n      <div className=\"h-100 row align-items-center\">\n        <div className=\"col-md-3\"></div>\n        <div className=\"col-md-6 \">\n          <TextareaMentions\n            ref={textareaRef}\n            placeholder=\"Write your comment here...\"\n            className=\"container-fluid\"\n            rows={5}\n            value={text}\n            onMention={onMention}\n            onChange={onChange}\n          ></TextareaMentions>\n          <button\n            className=\"badge badge-secondary float-right btn\"\n            onClick={insertMention}\n          >\n            @\n          </button>\n        </div>\n        <div className=\"col-md-3\"></div>\n\n        <div className=\"col-md-3\"></div>\n        <div className=\"col-md-6\">\n          <h4>Testing on contentEditable (not working yet)</h4>\n          <div\n            contentEditable\n            // onInput={event =>\n            //   event.currentTarget.textContent &&\n            //   setText(event.currentTarget.textContent)\n            // }\n            style={{ backgroundColor: '#FFF', height: 100 }}\n            dangerouslySetInnerHTML={{\n              __html: `${textAlt}`,\n            }}\n          ></div>\n          <div className=\"col-md-3\"></div>\n        </div>\n      </div>\n    </>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { Root } from './components/root/root';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"UserDropdown\":\"user-autocomplete_UserDropdown__mqmfN\",\"UserAvatar\":\"user-autocomplete_UserAvatar__9TRGG\",\"FocusUser\":\"user-autocomplete_FocusUser__1ROfc\"};"],"sourceRoot":""}